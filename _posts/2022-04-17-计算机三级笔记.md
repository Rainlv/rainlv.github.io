---
title: 计算机三级笔记
date: 2022-04-17 23:08:07 +0800
---

## 生命周期模型

- 项目规划

  - 系统规划与定义
  - 可行性分析
    - 经济
    - 操作：人员、软硬件、工作环境等
    - 技术
    - 开发方案可行性
  - 项目规划

- 需求分析

  - 数据需求分析
  - 性能需求分析

- **_系统设计_**

  - 概念设计：数据库概念模型设计、系统总体设计
  - 系统总体设计：DBAS 体系结构设计，硬件平台选型和配置，应用软件结构设计，对业务规则进行初步设计，对关键技术进行选型和初步设计
  - 逻辑设计：数据库逻辑结构设计、数据库`事务概要`设计、应用程序概要设计。
  - 物理设计：数据库物理结构设计、数据库`事务详细设计`、应用程序详细设计。

- 实现与部署

  建立数据库结构，数据加载，事务和应用程序的编码与测试，系统集成、测试与试运行，系统部署

- 运行与维护

## 需求分析

过程：标识问题，建立需求模型，描述需求，确认需求

#### 需求

###### 功能需求

###### 性能需求

######## 性能指标

- 数据操作响应时间

- 系统(数据)吞吐量：系统单位时间内所完成的事务或查询的数量，单位是 TPS。

- 允许并发访问的最大用户数

  每 TPS 代价值，用于衡量系统性价比的指标。

提高吞吐量：大事务分解为小事务，避免死锁，降低隔离性等级

###### 数据需求

数据模型三要素：

- 数据结构

- 数据操作
- 数据完整性约束

###### 其他需求

- 存储需求：存储量
- 安全需求

#### 建模方法

###### IDEF0

两种元素：

- 矩形框（活动）
- 箭头

![](/assets/img/screenshots/2022-04-17-23-12-36.png)
![](/assets/img/screenshots/2022-04-17-23-12-57.png)

###### UML

###### DFD

四种基本元素：

- 数据流：`箭头`。
- 处理：`矩形框`。数据逻辑处理，数据变换
- 数据存储：`圆角矩形框`。
- 外部项：`圆角框或平行四边形框`。数据来源和去路。（系统外部）

**数据流图**

一个处理至少一个输入流和输出流

一个存储必须有流入和流出的数据

一个数据流至少一段是处理框

## 数据库结构设计

#### 概念设计

###### 数据建模方式

######## ER

######## IDEF1X

- 实体集：

  - 独立实体集：每个实例都能够被唯一标识而不决定于它与其它实体集的联系 –> `矩形框`
  - 从属实体集：实例依赖于其它实体集的实例 –> `圆角矩形框`

- 联系：
  - 标定型联系：由两个父实体集共同确定（外码有两个，并取决于不同的表） –> `实线`连接单点，1 端是起点，n 端是终点(用实心圆点表示)
  - 非标定型联系：无需了解父端的实例 –> `虚线`连接单点
  - 分类联系：是两个或多个实体集之间的联系，且在这些实体集中存在一个一般实体集，它的每一个实例都恰好与一个且仅一个分类实体集的一个实例相联系。例如，本科生和学生就属于分类联系。 –> 单点`实线`两杠
  - 不确定联系：一个非确定联系又称为**多对多**联系，这种联系关联的两个实体集之间，任一实体集的一个实例都将对应另一实体集的 0 个、1 个或多个实例。 –> 两点`实线`
- 一些结论：
  - 标定型联系中，子女实体集总是从属实体集

#### 逻辑设计

关系模式设计、规范化处理

> 例：视图设计

###### ER 图转关系模型

关系模式数量 = 实体集数量 + 多对多联系数量

- 实体转化为独立的模式
- 多对多联系转换为关系模式
- 一对多联系中一端并入到多端的实体中

###### 范式

**函数依赖**

- 完全函数依赖
  - 例：学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）
- 部分函数依赖
  - 例：学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖于（学号，身份证号）
- 传递函数依赖
  - 定义：设 X,Y,Z 是关系 R 中互不相同的属性集合，存在 X → Y(Y !→X),Y → Z，则称 Z 传递函数依赖于 X。
  - 例：在关系 R(学号 ,宿舍, 费用)中，(学号) -> (宿舍),宿舍 !->学号，(宿舍) -> (费用),费用 !-> 宿舍，所以符合传递函数的要求。
- 多值依赖
  - 例如：职工表(职工编号，职工孩子姓名，职工选修课程)，在这个表中，同一个职工可能会有多个职工孩子姓名，同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如职工表一(职工编号，职工孩子姓名)，职工表二(职工编号，职工选修课程)，两个表都只有一个多值事实，所以符合第四范式。

**范式**

- 第一范式 1NF：关系模式不包含多值属性
- 第二范式 2NF：消除非主属性对主码的部分函数依赖。实体的属性完全依赖于主关键字
- 第三范式 3NF：消除传递依赖。属性不依赖于其它非主属性
- 巴斯-科德范式 BCNF：消除对主码子集的依赖。任何非主属性不能对主键子集依赖
- 第四范式 4NF：消除多值依赖。

一般来说，只有两个属性的表可以到达 4NF

#### 物理设计

物理结构角度要考虑的问题：文件的组织，文件的结构，文件的存取和索引技术。

内容：数据库逻辑模式描述，文件组织和存取设计，数据分布设计，确定系统配置，物理模式评估。

> 例：去规范化、表分区

###### 索引

- 散列索引：不适合用于模糊(范围)查询，适合点查询

- 有序索引：适合模糊(范围)查询和点查询

  - - 聚集索引(`CLUSTERED`)：索引文件中索引项排列顺序和数据排列顺序相一致
    - 非聚集索引(`NONCLUSTERED`)：反之。
  - 聚集索引跟适合范围查询

  - - 稠密索引：每个查找码都对应一个索引记录
  - 稀疏索引：部分查找码对应了索引记录

  - - 主索引：主码属性集上建立的索引
  - 辅索引：非主属性上建立的索引

- - 唯一索引(`UNIQUE`)：索引属性列都是唯一的

- - 单层索引
  - 多层索引

- - 复合索引：效率高于单一索引

  - 单一索引

> 适合索引使用条件：
>
> - 在经常需要搜索的列上，可以加快搜索的速度
> - 在经常使用连接的列上（这些列主要是一些外键）可以加快连接的速度，在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
> - 在经常使用`WHERE`子句中的列上面创建索引，加快条件的判断速度。
> - Group by,Order by 也行，但 select 不行
>
> 不适合使用的条件：
>
> - 对于那些在`查询中很少使用`或者参考的列不应该创建索引
> - 对于那些只有`很少数据值的列`也不应该创建索引
> - `经常更新的列`不适宜创建索引

> 模糊查询不会访问索引

###### 文件分类

- 散列文件：散列存储方式组织的文件
  - 优点：文件随机存放，无需排序，插入删除方便，存取速度快，不需要索引节省空间
  - 缺点：不能顺序存取
- 堆文件
  - 数据库中的一个基本表的数据量很少，并且插入删除更新频繁，可以采用堆文件
  - 优点：无需建立索引，维护代价低，在数据量少时定位文件记录时间短
  - 缺点：数据访问效率低
- 顺序文件
  - 如果用户的查询条件定义在查找码上，则顺序文件是比较适合的文件结构
  - 优点：支持顺序存取和随机存取，顺序存取快
  - 缺点：文件不能动态增长，不利于插入和删除
- 聚集文件
  - 将不同关系表中有关联关系的记录存储到一起。
  - 如果频繁使用多表连接的查询，可以考虑聚集文件来改善查询效率

## 数据库应用系统功能设计与实施

B/S 结构的数据库应用系统：

- 浏览器
- 应用服务器
- 数据库服务器

按功能分为四个层次：

- 表示层：用户交互
- 业务逻辑层
  - 表示层的数据加工处理传递给数据访问层
  - 数据访问层获得的数据加工处理在表示层展示
  - 例：存储过程设计、**构件设计**
    - 构件设计
      - 单一责任原则
      - 功能独立，减少重叠
      - 接口简单明确
      - 如果两个构件间的关系比较复杂，应考虑进一步进行模块划分（不能合并！）
      - 如果构件过于复杂，可以细分
- 数据访问层：与数据库交互，提取或存入数据。
- 数据持久层：负责保存和管理应用系统数据。
  - 例：数据完整性维护、调整数据文件组织结构、索引设计、存储结构设计

安全：

- 用户身份鉴别
- 权限控制
- 视图控制

## UML

#### 四层建模概念框架

​ **下层的每个概念是上层的一个实例**

- 元元模型层：组成了 UML 的最基本的元素“事物”
- 元模型层：组成 UML 的基本元素
- 模型层：组成 UML 的模型
- 用户模型层：其中的所有元素都是 UML 模型的实例

#### 结构图

定义：对系统静态结构建模，反应模块层次结构

- 类图：展现一组类、接口和协作以及它们之间的关系的一种静态视图

  - 关系：

    - 聚合：空心菱形实线
    - 组合(不能离开整体)：实心菱形实线
    - 实现：空心三角虚线
    - 泛化：空心实线三角，即继承

    一对多关系用：`1 : *`表示

- 组件图

- 对象图

- 部署图

#### 行为图

定义：系统动态行为建模

- 用例图
  - 组成
    - 用例、系统、角色
  - 关系
    - 扩展、包含、泛化（扩展、使用、组合）
- 交互图
  - 顺序图：描述对象自身及对象间消息传递顺序的视图
  - 通信图(协作图)：交互图的一种，其中包含一组对象、对象之间的联系以及对象发送和接收的消息
  - 时间图
  - 交互概述图
- 状态图：描述一个实体在发生一些事件时的状态变化情况
- 活动图

顺序图表示递归过程，当一个操作调用它本身时，消息总是`同步`的

## SQL

#### 谓词

###### EXIST

#### 集合操作符

###### UNION / UNIAN ALL

请注意，UNION (ALL)内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。

######## UNION

合并两个或多个 SELECT 语句的结果集，会对结果去重。

例：

```sql
SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2
-- 获取表1、表2中所有的column_name，重复的只取一次
```

######## UNIAN ALL

UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值，即不去重。

例：

```sql
SELECT E_Name FROM Employees_China
UNION ALL
SELECT E_Name FROM Employees_USA
-- 获取Employees_China和USA中所有的E_Name，不去重
```

###### IN

###### EXCEPT

在第一个集合中存在，但是不存在于第二个集合中的数据。

###### INTERSECT

两个集合的交集。

#### 语句

###### DISTINCT

查询结果去重

例：

```sql
SELECT DISTINCT Company FROM Orders
```

###### TOP

top n (with ties) 表示选取最多的前 n 个，with ties 要与 top 和 order by 一起使用，表示包含最后一行并列结果。

top n percent 表示选取查询结果的前%n 行。

例：

```sql
SELECT top 3 with ties a, b, c  from t1 order by id
-- a值前3的记录(含并列)
```

###### CASE

简单的条件赋值语句

语法结构：

```sql
CASE 测试表达式
	When 简单表达式1 THEN 结果表达式1
	When 简单表达式2 THEN 结果表达式2
	When 简单表达式3 THEN 结果表达式3
	[ELSE 结果表达式]
END
```

例：

```sql
CASE sex
	When '1' THEN '男'
	When '0' THEN '女'
	ELSE '爬开'
END
```

```sql
CASE
	WHEN sex='1' THEN '男'
	WHEN sex='0' THEN '女'
	ELSE '爬开'
END
```

###### 公用表达式

###### 常用函数

######## DATEDIFF：计算时间差

###### 开窗函数

###### 用户自定义函数

######## 声明

```sql
CREATE FUNCTION  -- 定义
ALTER FUNCTION  -- 修改
DROP FUNCTION  -- 删除
```

######## 标量函数

返回值可以是除了`timestamp`类型以外的所有数据类型

######## 内嵌表值函数

类似带参数的视图

- 返回值是一个表，是查询语句的结果
- 使用时，一般放在查询的 FROM 子句中
- 通过 SELECT 语句填充函数返回的表值

######## 多语句表值函数

- 只有标量函数可以出现在 SELECT 语句目标列中，其余两个函数必须放在 SELECT 语句的 FROM 子句中

#### 触发器

###### 定义

`FOR / AFTER`声明的触发器是后触发器，在语句操作完成，约束检查成功后执行

`INSTEAD OF` 创建的是前触发器，执行触发器来替代语句

一张表可以有多个后触发器，当对于同一数据操作(如 UPDATE)只能有一个前触发器

视图不能定义触发器

例：

```sql
-- 后触发器
CREATE TRIGGER tri_name on T FOR UPDATE AS ...
-- 前触发器
CREATE TRIGGER tri_name on T INSTEAD OF UPDATE AS ...
```

#### 游标

###### 声明

```sql
-- 定义
DECLARE cursor_name CURSOR FOR -- FOR！
SELECT ...
```

###### 使用

如果声明游标时不指定 SCROLL 选项，使用 FETCH 时只能使用 NEXT

```sql
FETCH [NEXT | PRIOR | FIRST | LAST | ABSOLUTE{n|@nvar} | RELATIVE{n|@nvar}] FROM cursor_name
/*
NEXT：下一行
PRIOR：上一行
FIRST：第一行
LAST：最后一行
ABSOLUTE{n|@nvar}：如果n或@nvar为正，则返回从第一行开始数的第n行；如果n为负，则返回倒数第n行
RELATIVE{n|@nvar}：如果n为正，返回当前行往下数的第n行；如果n为负，则返回当前行往上数的第n行
*/
```

判断游标数据提取状态的全局变量：`FETCH_STATUS`

- =0 时：表明 FETCH 成功
- =-1 时：表明 FETCH 失败，或行不在结果集中
- =-2 时：提取的行不存在

#### 存储过程

```sql
CREATE PROC proc_name
@变量1, @变量2 AS sql语句
```

## 安全权限管理

多角色权限冲突时，优先 DENY，其余权限取并集。

数据库用户可以分为：系统管理员、对象拥有者、普通用户

#### 主要角色及权限

- 服务器角色：

![](/assets/img/screenshots/2022-04-17-23-14-29.png)

- 数据库角色：

![](/assets/img/screenshots/2022-04-17-23-14-44.png)

#### 权限管理

赋予权限：

```sql
GRANT 权限名 ON 库名(表名) TO 用户名
GRANT 权限名 ON 表名 TO 用户名

-- 例：授予用户U1具有创建表和视图权限
GRANT CREATE TABLE, CREATE VIEW TO 用户名
```

- 在授权时，如果要使用户可以将授予他的权限转授他人，需要加上`WITH GRANT OPTION`选项

  ```sql
  GRANT 权限名 ON 表名 TO 用户名 WITH GRANT OPTION
  ```

不允许用户获得某种权限：

```sql
DENY 权限名 ON 库名(表名) TO 用户名
DENY 权限名 ON 表名 TO 用户名
```

收回已经授予的权限：

```sql
REVOKE 权限名 ON 表名 FROM 用户名
```

- 使用 REVOKE 回收权限时，如果要将用户转授给其他用户的权限一起回收，要加入`CASCADE`选项

#### 安全性分级

- A：验证保护
- B：强制保护
- C：自主保护
- D：最小保护

#### 账户管理

###### 身份验证模式

两种身份验证方式：混合身份验证模式、Windows 身份验证

在 WIndows 身份验证模式下，不允许 sa 登录到 SQL server 服务器

不管哪种身份验证模式，Windows 的 Administrator 无需授权就能登录到 SQl server 服务器

###### guest 账户

没有对应的登录名

任何 SQL server 登录账户都可以访问 guest 用户的数据库

###### 创建账户

```sql
CREATE LOGIN 用户名 WITH PASSWORD='密码'
```

###### 删除账户

```sql
DROP LOGIN 用户名
```

## 运行与维护

例：引入汇总表

性能优化：

- 重组：不修改原有设计的逻辑结构和物理结构
- 重构：部分修改

冗余列：减少连接

派生冗余列：减少聚合函数

## 故障管理

转储机制：

​ 效率：完全 < 差量 < 增量

​ 空间占用：差量 > 增量

​ 恢复速度：完全 > 差量 > 增量

- 完全转储：对整个数据库的数据全部重新备份
- 差量转储：基于上一次完全转储基点之后变化转储，对修改和删除记录的转储
- 增量转储：只复制上次转储后发生变化的文件或数据块。

- 静态转储：保证数据有效性，牺牲数据库可用性。数据库不能运行其他事务，不允许有任何修改活动
- 动态转储

故障：

- 事务(内部)故障
  - 预期
  - 非预期：运算溢出、并发事务死锁、违反完整性限制
- 系统故障：又叫软故障
  - 如：硬件故障、数据库软件及操作系统漏洞、突然停电等
- 介质故障
- 计算机病毒

数据库镜像

- 高保护
- 高可用
- 高性能

**备份**

- 完全备份：备份所有数据和日志
- 差异备份：备份自上一次完全备份后产生的完全备份

```sql
BACKUP DATABASE 数据库名 TO 设备名 [选项]
/* 选项
WITH DIFFERENTIAL：表示差异备份
NOINIT：表示将此次备份追加到指定的媒体集，以保留原有的备份集。
*/
```

事务日志备份：

- 纯日志备份：仅包含一定间隔的事务日志记录而不包含再大容量日志恢复模式下执行的大容量更改的备份
- 大容量操作日志备份：包含日志记录和大容量操作更改的数据页的备份，不允许对大容量操作日志备份进行时点恢复
- 结尾备份：对可能已损坏的数据库进行日志备份，可以百行纯日志记录或大容量操作记录

文件备份只对数据文件备份，日志文件需要再备份

对 master 数据库只支持完整备份

执行任一更新数据库的操作后，要对 model 数据库备份

**恢复**

恢复模式

- 简单恢复：无日志备份。用于测试和开发，或用于主要包含只读数据的数据库(如数据仓库)。
- 完整恢复：需要日志备份。如，还原单个数据页
- 大容量日志恢复：需要日志备份。是完整恢复的附加模式，不支持时点恢复，使用最小方式记录大多数大容量操作，来减少日志空间使用量。

**恢复顺序**

恢复最近的`完全`数据库备份

恢复完全备份之后的最近的`差异`数据备份

按日志备份的先后顺序恢复自最近的完全或差异数据备份之后的所有日志备份

## 数据库及数据库对象

数据文件：

- 数据库中主要数据文件的大小不能小于`model`数据库主要文件大小，model 数据库为新创建的数据库提供模板。

- 主数据文件必须建立在`主文件组`中（大小不能小于 3MB），次要数据文件也可以存在在主文件组

- 每个数据库只有一个主要数据文件，可以有多个次要数据文件

- 日志文件不包含在文件组中

- 一个数据文件属于一个文件组

分离附加数据库：

- 分离前要断开连接
- 分离数据文件和日志文件
- 分离数据库需要停用被使用的数据库，但不能停止 SQL server 服务

数据库：

- master：记录数据库实例的系统级信息
- msdb：存储实例的作业信息
- tempdb：每次启动都会重新创建
- Resource：包含数据库所有系统对象

分区：–> 对表中数据进行水平/垂直划分

- 步骤
  - 创建分区函数：确定以什么方式对表分区
  - 创建分区方案：分区函数生成的分区映射到文件组中
  - 使用分区方案创建表
- 分区函数
  - LEFT，范围包右不包左；RIGHT，范围包左不包右

标识列：identity

## 大规模数据库架构

#### 分布式数据库

通信代价最大的是各个站点`分片间`连接和并操作

分布式数据库的分布透明性包括

- 分片透明性(最高层次)：只对全局关系进行操作，不考虑关系分片。位于全局概念模型和分片模型之间
- 位置透明性：只需了解数据分片情况，不需要了解片段的存储场地
- 局部数据模型透明性：了解数据分片情况，了解片段的存储场地。位于分配模式和局部概念之间

分片类型：

- 水平分片
- 垂直分片
- 导出分片
- 混合分片

分布式数据库中，使用`半连接`操作可以减少场地之间的数据传输量

分布式数据库中，使用`分配`模式来描述各片段到物理存放场所的映像

最基本特征：`本地自治、非集中式管理、高可用性`

分布式数据库系统的恢复控制采用的最典型策略是基于`两阶段`的提交协议

#### 并行数据库

划分方法：

- 轮转法：最适合整表扫描
- 散列划分：适合点查询，也适合顺序扫描
- 范围划分：适合范围查询和点查询

分布策略：

- 集中式：所有数据片段都安排在一个场地
- 分割式：全局数据只有一份，但被分割成多个片段，每个片段分配在特定场地
- 全复制式：每个站点上都有全局数据的复制样本，数据冗余大
- 混合式：混合使用上述策略，介于分割式和全复制式

结构

- 无共享结构：独立磁盘，内存。 –> 满足高并发，OLTP
- 共享结构：共享磁盘，内存。
- 层次结构：顶层是无共享结构，底层是共享结构

## 数据挖掘与数据仓库

#### 数据挖掘

算法：

- 关联规则挖掘
  - 指标：支持度、置信度
- 聚类
- 分类

数据管理和分析形式

- OLTP(联机事务处理)：对数据的查询和修改。要求快速响应操作，对数据的安全性、完整性及事务吞吐量要求高
- OLAP(联机分析处理)：访问的数据率大，查询和分析操作复杂

OLAP 的实现方式

- MOLAP：基于多维数据库
- ROLAP：基于关系型数据库
- HPLAP：混合型

知识发现由三个步骤组成，数据准备、数据挖掘、结果解释评估

高粒度数据视图切换到低粒度数据视图的分析操作叫`钻取`

#### 数据仓库

数据仓库是面向主题的、集成的、非易失的、且随时间变化的数据集合

元数据可以分为`技术`元数据和`业务`元数据

为了解决不同数据源格式上的不统一，需要进行的数据操作是`转换`

特征

- 不可更新性：用户对在提取仓库中的数据进行分析时不会同时对数据仓库中的数据进行更新操作

- 数据变化性：数据仓库每隔一段时间进行数据的更新和处理。更新与时间间隔有关，不会实时更新

## 其他

- 分布式数据库
  - 目标：`本地自治、非集中式管理、高可用性`、位置独立性、数据分片独立性、数据复制独立性、分布式查询处理、分布式事务管理、硬件独立性、操作系统独立性、网络独立性、数据管理系统独立性。
  - 特点：独立透明性、集中结点结合、复制透明性、易于扩展性
  - 缺点：开销大，主要是通信；数据安全性和保密性难处理
- 并行式数据库
  - 目标：高性能和高可用性，通过多个处理节点并行执行数据库任务，提高整个数据库系统的性能和可用性。

---

###### 约束

关系级别约束：主外键约束

列级约束：非空、唯一

元组约束：CHECK

数据完整性定义：

- 实体完整性：主键
  - 级别
    - 元组
    - 列：值类型、范围、精度、排序等
    - 表(关系)：
- 参照完整性：外键
- 自定义完整性：定义属性上的约束条件，如非空(NOT NULL)、列值唯一(UNIQUE)、列值满足表达式(CHECK)

---

###### `三级模式`

- 外模式：用户可见的部分`数据`的存在形式。
- 模式：全体数据的`逻辑结构`且用户不可见。
- 内模式(唯一)：数据库的`物理结构和存储方式`。

二级映像：

- 外模式/模式映像保证了数据与程序的`逻辑`独立性。

- 模式/内模式的映射保证了数据库中数据与应用程序间的`物理`独立性。

###### 关系与关系模式

- 关系模式：二维表的`表头属性`等，即一个二维表的主要架构。由于二维表的属性名一般不会修改，所以呈现出`静态`。
- **关系**是一张二维表的`具体数据`，除去表头外各数据间的联系。由于二维表中是数据会时常修改，所以呈现出`动态`。随用户对数据库的操作而改变。

###### 磁盘

RAID1：提高了写速度，磁盘利用率低

RAID5：写入速度比 RAID1 慢，磁盘利用率高

RAID10

###### 视图

特点：

- 简单性：见到的就是需要的。
- 安全性：通过视图，用户只能查询和修改他们所能见到的数据。
- 逻辑数据独立性：屏蔽真实表结构变化带来的影响。

作用：

- 简化数据查询语句
- 使用户从多角度看待同一数据
- 提高数据安全性

索引视图：–> 建立了唯一聚集索引的视图

- 数据源只能是同一数据库中的基表，不能是视图

- 索引视图的数据被物理地保存在数据库中，会占空间。因为创建唯一聚集索引会物理地保存数据。普通视图不占空间。

- > 不合适情况：
  >
  > ​ 数据更新频繁
  >
  > ​ 不涉及聚集和连接的查询
  >
  > ​ group by 具有高基数度(表示列具有许多不同值)

###### 事务

事务规范：

- 事务名称
- 事务描述(处理逻辑)
- 事务所访问的数据项(关系表/模式)
- 事务用户

检测死锁：

- 超时法
- 等待图法：周期性的生成事务等待图进行检测。(不是在执行每个事务时检测！)

防止死锁：

- 大事务切分为小事务
- 事务按同一顺序访问资源
- 使用绑定链接
- 降低事务隔离性级别

事务特性：

- 原子性
- 一致性：事务的隔离执行，保持数据库的一致性
- 隔离性：
- 持久性：每个事务成功完成后，它对数据库的改变必须是永久的，即使系统出现故障

事务`概要`设计阶段，用 read、write 原语来表达存取结构

两阶段加锁协议保证事务调度的`可串行性`

---

数据定义语言`DDL`

- 数据定义语句经过 DDL 编译器编译后，各种对象的描述信息存放在数据库的`数据字典`中。
- 数据字典包括`数据项`、`数据结构`、`数据流`、`数据存储`和`处理过程`。
- 执行后不能回滚

概念数据模型不描述数据的完整性约束。

不同数据库管理系统有着不同的逻辑实现结构，数据库空间管理方法不同！

数据库架构与用户是一对多关系

## 编程题

多语句表值函数

```sql
create function Fun_StudentScore(@gender bit)
returns @stuScore table
(
  stuNo char(9),
  stuName nvarchar(8),
  city nvarchar(8),
  math int
)
as
begin
 insert into @stuScore select stuNo,stuName,city,math from student join score
   on student.id=socre.stuId where student.gender=@gender
   if(@gender=0)
   begin
     update @stuScore set math=math+10
   end
   return
end



--调用
select * from dbo.Fun_StudentScore(1)
```

创建分区方案

```sql

```

SQL 查询

创建存储过程

```sql
CREATE PROCEDURE proc_stu
  @notpassSum int OUTPUT, /*输出（返回）参数：表示没有通过的人数*/
  @writtenPass int=60,   /*推荐将默认参数放在最后*/
  @labPass int=60 
  AS
    ……
     SELECT stuName,stuInfo.stuNo,writtenExam, /*统计并返回没有通过考试的学员人数*/
        labExam FROM  stuInfo  INNER JOIN stuMarks
          ON stuInfo.stuNo=stuMarks.stuNo
            WHERE writtenExam < @writtenPass
              OR labExam<@labPass
    SELECT @notpassSum=COUNT(stuNo)
       FROM stuMarks  WHERE writtenExam<@writtenPass
           OR labExam<@labPass
GO

/*---调用存储过程----*/
DECLARE @sum int /*调用时必须带OUTPUT关键字 ，返回结果将存放在变量@sum中*/
EXEC proc_stu @sum OUTPUT ,64 
print '--------------------------------------------------'
IF @sum>=3 /*后续语句引用返回结果*/
  print '未通过人数：'+convert(varchar(5),@sum)+ '人,
        超过60%,及格分数线还应下调'
ELSE
  print '未通过人数：'+convert(varchar(5),@sum)+ '人,
        已控制在60%以下，及格分数线适中'
GO
```

触发器

```sql
/* 级联删除 */
create trigger t_std2 on student
instead of delete  -- 前触发器
as
begin
  declare @id char(5)
  select @id=sno from deleted
  delete from sc where SNo =@id
  delete from student where SNo=@id
end
```

```sql
/* 更新 */
create trigger t_teacher on teacher
after update -- 后触发器
as
begin
  declare @age int,@sal float
  select @age=age from deleted
  select @sal=sal from deleted
  if(@age <> (select age from inserted)and @sal <> (select sal from inserted))
  	print '更新了年龄和工资 '
  else if(@age <> (select age from inserted )and @sal = (select sal from inserted))
  	print '更新了工资 '
  else if(@age = (select age from inserted )and @sal <> (select sal from inserted))
  	print '更新了年龄 '
end
```

自定义标量函数

```sql
CREATE FUNCTION Sales.FetchProductOrderNum
(
    @ProuctID  INT
) RETURNS INT
BEGIN
    DECLARE @SaleOrderNum INT;
    SELECT @SaleOrderNum=COUNT(SalesOrderID) FROM Sales.SalesOrderDetail
    WHERE ProductID=@ProuctID
    GROUP BY ProductID;

    RETURN @SaleOrderNum;
END
```
